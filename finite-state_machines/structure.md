# Введение
## Трансляторы
### токены
### лексемы
### Лексический разбор
### Синтаксический разбор
### Семантический разбор
# Формальные языки
## Алфавит, символы алфавита, слово алфавита
## Операции над словами
1) конкатенация
2) степень слова
3) префикс / суффикс
## Язык алфавита
1) объединение
2) пересечение
3) дополнение до множества всех слов алфавита
4) произведение
5) степень языка
6) итерация
### Способы задания языков
1) Конечный набор правил порождения слов
2) Распознаватель слов : на слово из $\Sigma^*$ да/нет
## Регулярные языки
### Регулярные выражения
# Конечные автоматы
## Детерминированные конечные автоматы
**Детерминированный конечный автомат** (ДКА) –
это набор из пяти элементов $(Q, \Sigma, q_0, F, \delta)$, в котором:
* Q – конечное множество, элементы которого называем состояниями автомата,
* $\Sigma$ – конечный алфавит, который называем входным,
* $q_0 \in Q$ – начальное состояние,
* $F \subseteq Q$ – множество состояний, которое называем конечными,
* $\delta: Q \times \Sigma \to Q$ – функция переходов.
## Недетерминированные конечные автоматы
**Недетерминированный конечный автомат** (НКА) –
это набор из пяти элементов $(Q, \Sigma, q_0, F, \delta)$, в котором:
* Q – конечное множество, элементы которого называем состояниями автомата,
* $\Sigma$ – конечный алфавит, который называем входным,
* $q_0 \in Q$ – начальное состояние,
* $F \subseteq Q$ – множество состояний, которое называем конечным,
* $\delta: Q \times \Sigma \to P(Q)$ – функция переходов
# Преобразования КА
## Эквивалентные автоматы
**Определение** ДКА является полностью определенным, если его 
функция переходов $\delta: Q\times \Sigma \to Q$ всюду определена
## Преобразование НКА в полностью определенный ДКА
https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D0%9D%D0%9A%D0%90_%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2%D0%B0%D0%BB%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%94%D0%9A%D0%90,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A2%D0%BE%D0%BC%D0%BF%D1%81%D0%BE%D0%BD%D0%B0
1) Помещаем в очередь Q множество, состоящее только из стартовой вершины.

2) Затем, пока очередь не пуста, выполняем следующие действия:

    Достаем из очереди множество, назовем его q

    Для всех c∈Σ
    посмотрим, в какое состояние ведет переход по символу c
    из каждого состояния в q. Полученное множество состояний **положим в очередь Q**
    только если оно не лежало там раньше. Каждое такое множество в итоговом ДКА будет **отдельной вершиной**, в которую будут вести переходы по соответствующим символам.

    Если в множестве q
    хотя бы **одна из вершин была конечной в НКА**, то соответствующая данному множеству вершина в ДКА также будет конечной.
    Конец.

Положим:
* Q'= P(Q) (т.е. состояниями нового автомата будут **всевозможные 
множества состояний исходного**),
* q0' = { q0
},
* F’ = { S | S $\subseteq$ Q, S $\cap$ F ≠ $\varnothing$ } (заключительные состояния нового 
автомата — это множества, содержащие **хотя бы одно 
заключительное состояние исходного** автомата). 
* Для множества $S \in Q’$ и символа $a \in \Sigma$ положим 
$\delta’(S, a)$ = { $p \in Q \;|\; \exists q \in S\quad p \in \delta(q, a) $}

новое состояние $\delta ’(S, a)$ строится 
так: берем все элементы множества S, это **состояния старого 
автомата**, **действуем** на них функцией перехода старого автомата и 
**объединяем** полученные состояния в одно множество, это 
множество и будет новым **состоянием автомата A’**.
# Минимизация конечных автоматов
https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%94%D0%9A%D0%90,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%B7%D0%B0_O(n%5E2)_%D1%81_%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%BF%D0%B0%D1%80_%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D0%BC%D1%8B%D1%85_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9
## Недостижимые состояния
## k-неразличимые состояния
### Алгоритмы устранения недостижимых и неразличимых состояний
## Приведенный автомат
### является минимальным среди эквивалентных
# Построение автомата по регулярному выражению
## Автоматы с $\varepsilon$-дугами
## Теорема Клини
Классы регулярных языков и языков, 
распознаваемых ДКА совпадают.
# Свойства регулярных языков
## Операции над регулярными языками
**Теорема.** Пусть L1 и L2 — регулярные языки алфавита $\Sigma$. Тогда их 
объединение, пересечение, дополнение до множества всех слов 
алфавита и разность тоже регулярные языки.
## Лемма о разрастании
Язык арифметических 
выражений, составленных из символов id (это один именованный 
терминал), +, *, ( и ) не является регулярным
## Неразрешимые проблемы
Примеры алгоритмически неразрешимых проблем:

+ **Проблема остановки.** По произвольному алгоритму A и входу x
определить, верно ли, что алгоритм A остановится на входе x.
+ **Проблема пустоты языка.** По алгоритму A определить, верно ли, 
что он не останавливается ни при каком входе?
+ **Проблема эквивалентности**. По двум алгоритмам A1 и A2
определить, верно ли, что они определяют одну и ту же 
вычислимую функцию.
Эквивалентные этим проблемы разрешимы для конечных автоматов.
# Построение лексического анализатора
# Формальные грамматики
Грамматика — это четверка элементов G = (N, T, S, P), в
которой:
* N — конечное множество, элементы которого называем
**нетерминальные** символы или, для краткости, нетерминалы,
* T — конечное множество, не пересекающееся с N, элементы которого
называем **терминальные** символы или терминалы,
* S $\in$ N — выделенный нетерминал, который называем **стартовым
символом** грамматики,
* P — конечное множество слов вида $\alpha \to \beta$, называемых **правилами
грамматики**, в которых $\alpha, \beta \in (N \cup T)*$, слово $\alpha$ содержит хотя бы
один нетерминал.
## Терминальные символы
## Нетерминальные символы
## Грамматика
### Вывод в грамматике
Слово $\beta$ непосредственно выводится из слова $\alpha$ в 
грамматике G (обозначение: $\alpha \Rightarrow_G \beta$), если эти слова можно 
представить как $\alpha = x\gamma y, \beta = x \delta y$, и грамматика содержит правило $\gamma \to \delta$.
### Язык грамматики
Определение. Язык грамматики G = (N, T, S, P) — это все слова,
состоящие только из терминалов, которые выводятся из стартового
символа грамматики:
$L(G)  = \{\omega \in T^* | S \Rightarrow^* \omega\}$
| | |  |
|----------|----------|----------|
|  Маленькие буквы из начала латинского алфавита  | a, b, c...   | терминалы  |
| Заглавные буквы из начала латинского алфавита    | A, B, C...  | Нетерминалы (если не оговорено противное, стартовый символ - S)  |
| Заглавные буквы из конца латинского алфавита | U, V, W, X, Y, Z   | терминалы или нетерминалы   |
| Маленькие буквы из конца латинского алфавита |  u, v, w, x, y, z | слова, состоящие только из терминалов |
| Греческие буквы | $\alpha, \beta, \gamma, \delta$...| слова из множества $(N \cup T)^*$, т.е. слова, которые могут содержать и терминалы, и нетерминалы|
|<имя>||именованный нетерминал (это один  символ)|
| имя | |  именованный терминал (один символ)|

Также в рассуждениях о грамматиках буквами N и T будем 
обозначать множества нетерминалов и терминалов грамматики.
## Основная задача синтаксического анализа
По заданным грамматике G и слову w определить, верно ли, что 
$w \in L(G)$, и если да, то **восстановить вывод этого слова** в 
грамматике.
## Классификация грамматик
Иерархия Хомского:
1) *Праволинейные*

это грамматики, все правила 
которых имеют вид либо $A \to xB$, либо $A \to x$, где $A, B \in N, 
x \in T^*$.

Т.е. в **левой** части правила всегда **один нетерминал**, а в правой 
либо **нетерминалов нет вообще**, либо **нетерминал** единственный, 
и это **крайний справа символ**.

Распознаватели - конечные автоматы

### Язык праволинейный $\Leftrightarrow$ L является регулярным $\Leftrightarrow$ является автоматным

2) *Контекстно-свободные*

это грамматики с 
правилами вида $A \to \alpha$, где $A \in N, \alpha \in (N \cup T)^*$, т.е. в правилах 
слева **строго один нетерминал**, справа — **произвольное слово**, 
содержащее как терминалы, так и нетерминалы.

Используются в языках программирования

Конечные автоматы со стеками

3) *Контекстно-зависимые*

 (другое название — **не укорачивающие**) 
грамматики содержат правила вида $\alpha \to \beta$, где $\alpha$ и $\beta$ —
произвольные слова, но $|\alpha| ≤ |\beta|$.

4) *Общего вида*

Машина Тьюринга

# Контекстно-свободные грамматики
## Левый правый выводы слова 
**Определение.** Вывод слова w в КС-грамматике G назовем левым
(правым), если на каждом шаге вывода **очередное правило** 
применяется к самому *левому (правому)* **нетерминалу** слова.

## Дерево разбора слова в КС-грамматике
- это дерево, в узлах которого стоят символы из
множества $N \cup T \cup {\epsilon}$. При этом выполнены следующие условия.
* **Корень дерева** — стартовый символ грамматики S.
* **Листья дерева** — терминалы или $\epsilon$ (пустое слово).
* **Узлы дерева**, которые не являются листьями, содержат
нетерминалы. При этом, если узел содержит нетерминал A, а его непосредственые потомки содержат символы $X_1, ..., X_n$ (слева направо), то в грамматике G есть правило $A \to X_1...X_n$.
* Листья дерева **слева направо** образуют слово w.

Основная задача синтаксического разбора
превращается для КС-грамматики G в следующую: для заданного 
слова w построить **дерево разбора слова** в этой грамматике или 
доказать, что такое дерево не существует.
### Однозначные КС-грамматики 
**Определение.** КС-грамматика называется однозначной, если для 
каждого слова w из языка этой грамматики дерево разбора слова 
w единственное. В противном случае, грамматика называется 
неоднозначной.
# Преобразования грамматик
## Эквивалентные грамматики (порождают один и тот же язык)
### Недостижимый символ
**Определение.** Пусть G = (N, T, S, P) — КС-грамматика. Символ 
$X \in N \cup T$ назовем недостижимым, если нет выводов вида 
$S \Rightarrow* \alpha X\beta$.
### Бесполезный символ
**Определение.** Символ грамматики A $\in$ N назовем бесполезным, 
если не существует ни одного вывода вида $A \Rightarrow^* w$, где $w \in T^*$.

Другими словами, символ недостижимый, если ни в одном выводе 
его нельзя получить из **стартового символа** грамматики. 
Символ бесполезный, если из него нельзя вывести слово, 
состоящее только из терминалов (смысл грамматики —
**порождение слов, состоящих только из терминалов**).

Алгоритм устранения недостижимых символов: поиск в ширину

* M0 = { S },
* Mk+1 = { X | в грамматике есть правило A  X, A  Mk
}  Mk


Алгоритм устранения бесполезных символов в грамматике

Вход: КС-грамматика G = (N, T, S, P).

Выход: эквивалентная грамматика G’ без бесполезных символов.

**Метод.**
Нужно построить множество всех нетерминалов грамматики, из 
которых можно вывести слово, состоящее целиком из терминалов.

* N0 = { A | в грамматике G есть правило A  w, w  T*},
* Nk+1 = { A | в G есть правило A  ,   (T  Nk
)* }  Nk
.

## Цепное правило 
**Определение.** Правило грамматики вида $A \to B$, где A, B —
нетерминалы, назовем цепным правилом.

Алгоритм устранения цепных правил в КС-грамматике
+ Вход: КС-грамматика G = (N, T, S, P).
+ Выход: эквивалентная КС-грамматика G’ без цепных правил.
+ Метод. Идея алгоритма тоже простая. Наличие цепных правил 
позволяет строить выводы вида B1  B2 …  Bn  A  . Если 
мы уберем все цепные правила, то в таком выводе пропадут все 
стрелки, кроме последней. Чтобы их восстановить, добавим 
правила вида Bi  . **Проблема состоит в отыскании всех таких 
цепочек**.

+ N_{A,0} = { A }, 
+ N_{A,k + 1} = { C | в G есть правило C  B, где B  N_{A,k}
}  N_{A,k}.

## $\varepsilon$-правила
Правила вида A  
### Грамматика без $\varepsilon$-правил
если выполнено одно из двух условий:
+ либо G совсем не содержит -правил, 
+ либо в G есть единственное -правило, оно имеет вид S  , где 
S — **стартовый символ грамматики**, и символ S не встречается в 
**правых частях** правил.

Смысл ограничений второго пункта состоит в том, что 
единственное -правило используется в единственном выводе 
S   и более нигде.
## Левая рекурсия
**Определение.** Говорим, что КС-грамматика G допускает левую 
рекурсию, если существует вывод вида $A \Rightarrow^* A\alpha$. 
КС-грамматика G допускает непосредственную левую рекурсию, 
если в ней есть правило вида $A \to A\alpha$.
# Синтаксический разбор
## Простой нисходящий синтаксический разбор
Сложность : $O(2^n)$
## Простой восходящий разбор
### Свертка по правилу
# LL-грамматики
**Определение.** Для $k \ge 0$ класс **LL(k)** состоит из всех КС-грамматик, 
для которых на каждом шаге нисходящего синтаксического 
разбора очередное действие вычисляется однозначно по k
очередным входным символам. 
Грамматика является LL-грамматикой, если она принадлежит 
классу LL(k) при каком-то k.
## Грамматика с разделенными правилами
## Простейшие свойства LL-грамматик